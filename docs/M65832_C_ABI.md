# M65832 C Application Binary Interface (ABI)

**C Compiler Calling Conventions and Binary Interface**

Version 1.0  
January 2026

---

## Table of Contents

1. [Introduction](#1-introduction)
2. [Target Identification](#2-target-identification)
3. [Data Types and Alignment](#3-data-types-and-alignment)
4. [Register Usage](#4-register-usage)
5. [Function Calling Convention](#5-function-calling-convention)
6. [Stack Frame Layout](#6-stack-frame-layout)
7. [Return Values](#7-return-values)
8. [Parameter Passing](#8-parameter-passing)
9. [Variadic Functions](#9-variadic-functions)
10. [Struct and Union Passing](#10-struct-and-union-passing)
11. [Thread Local Storage](#11-thread-local-storage)
12. [Exception Handling](#12-exception-handling)
13. [LLVM Implementation Details](#13-llvm-implementation-details)

---

## 1. Introduction

This document defines the Application Binary Interface (ABI) for C programs compiled for the M65832 processor. It specifies the conventions that allow independently compiled code to interoperate, including:

- Data type sizes and alignments
- Register usage and preservation rules
- Function calling conventions
- Stack frame layout
- Parameter passing mechanisms

This ABI is designed for 32-bit native mode (E=0, M=10, X=10) with the register window enabled (R=1).

---

## 2. Target Identification

### 2.1 LLVM Target Triple

```
m65832-unknown-elf
m65832-unknown-linux
m65832
```

**Components:**
- **Architecture:** `m65832`
- **Vendor:** `unknown` (or specific vendor)
- **OS:** `elf` (bare metal), `linux` (Linux)
- **Environment:** (optional)

### 2.2 ELF Machine Type

| Field | Value | Description |
|-------|-------|-------------|
| `e_machine` | `0x6583` | EM_M65832 |
| ELF Class | 32-bit | ELFCLASS32 |
| Endianness | Little | ELFDATA2LSB |

### 2.3 LLVM Internal Identifiers

| Identifier | Value |
|------------|-------|
| Triple enum | `Triple::m65832` |
| Target name | `"m65832"` |
| Target description | `"M65832 [experimental]"` |

### 2.4 CPU Variants

| CPU | Features | Description |
|-----|----------|-------------|
| `m65832` | HWMul, Atomics | Standard configuration |
| `m65832-fpu` | HWMul, Atomics, FPU | With floating-point unit |

### 2.5 Data Layout String

```
e-m:e-p:32:32-i8:8-i16:16-i32:32-n32-S32
```

**Breakdown:**
- `e` - Little endian
- `m:e` - ELF name mangling
- `p:32:32` - 32-bit pointers, 32-bit aligned
- `i8:8` - i8 aligned to 8 bits
- `i16:16` - i16 aligned to 16 bits
- `i32:32` - i32 aligned to 32 bits
- `n32` - Native integer width is 32 bits
- `S32` - Stack alignment is 32 bits (4 bytes)

---

## 3. Data Types and Alignment

### 3.1 Fundamental Types

| C Type | Size (bytes) | Alignment (bytes) | LLVM Type |
|--------|--------------|-------------------|-----------|
| `_Bool` / `bool` | 1 | 1 | i8 |
| `char` | 1 | 1 | i8 |
| `signed char` | 1 | 1 | i8 |
| `unsigned char` | 1 | 1 | i8 |
| `short` | 2 | 2 | i16 |
| `unsigned short` | 2 | 2 | i16 |
| `int` | 4 | 4 | i32 |
| `unsigned int` | 4 | 4 | i32 |
| `long` | 4 | 4 | i32 |
| `unsigned long` | 4 | 4 | i32 |
| `long long` | 8 | 4 | i64 |
| `unsigned long long` | 8 | 4 | i64 |
| `float` | 4 | 4 | f32 |
| `double` | 8 | 4 | f64 |
| `long double` | 8 | 4 | f64 |

### 3.2 Pointer Types

| Type | Size (bytes) | Alignment (bytes) |
|------|--------------|-------------------|
| Data pointer | 4 | 4 |
| Function pointer | 4 | 4 |
| `void *` | 4 | 4 |
| `ptrdiff_t` | 4 | 4 |
| `size_t` | 4 | 4 |
| `intptr_t` | 4 | 4 |

### 3.3 Aggregate Types

- **Structs:** Aligned to the alignment of their most strictly aligned member
- **Unions:** Aligned to the alignment of their most strictly aligned member
- **Arrays:** Aligned to element alignment

### 3.4 Bit Fields

- Bit fields are packed from LSB to MSB within the underlying storage unit
- Storage unit size matches the declared type
- Bit fields do not cross storage unit boundaries unless zero-width

---

## 4. Register Usage

### 4.1 Register Classes

The M65832 has multiple register classes:

| Class | Registers | Width | Purpose |
|-------|-----------|-------|---------|
| GPR | R0-R63 | 32-bit | General purpose (via Direct Page) |
| FPR | F0-F15 | 64-bit | Floating-point (optional FPU) |
| Accumulator | A | 32-bit | Primary arithmetic |
| Index | X, Y | 32-bit | Indexing, scratch |
| Stack | SP | 32-bit | Stack pointer |
| Base | D, B | 32-bit | Direct Page base, Absolute base |

### 4.2 Register Allocation by Function

| Register | ABI Name | Usage | Preservation |
|----------|----------|-------|--------------|
| **R0** | a0/rv | Argument 1 / Return value | Caller-saved |
| **R1** | a1/rv2 | Argument 2 / Return value (high) | Caller-saved |
| **R2** | a2 | Argument 3 | Caller-saved |
| **R3** | a3 | Argument 4 | Caller-saved |
| **R4** | a4 | Argument 5 | Caller-saved |
| **R5** | a5 | Argument 6 | Caller-saved |
| **R6** | a6 | Argument 7 | Caller-saved |
| **R7** | a7 | Argument 8 | Caller-saved |
| **R8-R15** | t0-t7 | Temporaries | Caller-saved |
| **R16-R23** | s0-s7 | Saved registers | **Callee-saved** |
| **R24-R29** | — | Reserved (kernel) | — |
| **R30** | lr | Link register (optional) | Caller-saved |
| **R31** | — | Reserved | — |
| **R32-R47** | t8-t23 | Extended temporaries | Caller-saved |
| **R48-R55** | s8-s15 | Extended saved registers | **Callee-saved** |
| **R56-R63** | — | Reserved | — |
| **A** | — | Accumulator / scratch | Caller-saved |
| **X** | — | Index / scratch | Caller-saved |
| **Y** | — | Index / scratch | Caller-saved |
| **SP** | sp | Stack pointer | Special |
| **D** | — | Direct page base | Preserved |
| **B** | fp | **Frame pointer** / stack base | **Callee-saved** |

### 4.3 Caller-Saved Registers (Volatile)

Functions may freely modify these registers without saving:

```
R0-R15, R30, R32-R47, A, X, Y
```

### 4.4 Callee-Saved Registers (Non-Volatile)

Functions must preserve these registers across calls:

```
R16-R23, R48-R55, B
```

The **B register** (frame pointer) is callee-saved and must be preserved. It is saved via `PHB` in the prologue and restored via `PLB` in the epilogue.

If a function uses any callee-saved register, it must save the original value in the prologue and restore it in the epilogue.

### 4.5 Special Registers

| Register | Usage |
|----------|-------|
| **SP** | Stack pointer - modified by push/pop, function calls |
| **D** | Direct page base - typically points to register window (0) |
| **B** | **Frame pointer** - set to SP after stack allocation, used for `B+offset` addressing of local variables |

**Note:** The B register serves as the frame pointer in M65832. After allocating the stack frame, B is set to the current SP value, allowing locals to be accessed via `B+$offset` addressing. This is more efficient than traditional frame pointer usage since it doesn't require separate frame pointer save/restore logic beyond PHB/PLB.

### 4.6 Floating-Point Registers (FPU)

When the FPU is present (`-mcpu=m65832-fpu`), floating-point values use dedicated FP registers:

| Register | ABI Name | Usage | Preservation |
|----------|----------|-------|--------------|
| **F0** | fa0/frv | FP Argument 1 / FP Return value | Caller-saved |
| **F1** | fa1/frv2 | FP Argument 2 / FP Return (high for complex) | Caller-saved |
| **F2** | fa2 | FP Argument 3 | Caller-saved |
| **F3** | fa3 | FP Argument 4 | Caller-saved |
| **F4** | fa4 | FP Argument 5 | Caller-saved |
| **F5** | fa5 | FP Argument 6 | Caller-saved |
| **F6** | fa6 | FP Argument 7 | Caller-saved |
| **F7** | fa7 | FP Argument 8 | Caller-saved |
| **F8-F11** | ft0-ft3 | FP Temporaries | Caller-saved |
| **F12-F15** | fs0-fs3 | FP Saved registers | **Callee-saved** |

#### FP Caller-Saved (Volatile)

```
F0-F11
```

#### FP Callee-Saved (Non-Volatile)

```
F12-F15
```

#### FP Argument Passing

- First 8 floating-point arguments passed in F0-F7
- Additional FP arguments passed on stack
- FP arguments do not consume GPR slots (separate namespaces)

#### FP Return Values

| Type | Return Location |
|------|-----------------|
| `float` | F0 (single-precision in low 32 bits) |
| `double` | F0 (double-precision, full 64 bits) |
| `long double` | F0 (same as double) |
| `_Complex float` | F0 (real), F1 (imag) |
| `_Complex double` | F0 (real), F1 (imag) |

---

## 5. Function Calling Convention

### 5.1 Standard Calling Convention

The M65832 uses a register-based calling convention similar to ARM/RISC-V:

1. First 8 arguments passed in R0-R7
2. Additional arguments passed on stack (right to left)
3. Return value in R0 (or R0:R1 for 64-bit)
4. Caller cleans up stack arguments

### 5.2 Function Prologue

```asm
function:
    ; Save B register (frame pointer, callee-saved)
    PHB
    
    ; Allocate local variables (if needed)
    TSX                     ; X = SP
    TXA                     ; A = SP
    SEC
    SBC #locals_size        ; A = SP - locals_size
    TAX
    TXS                     ; SP = A (stack allocated)
    
    ; Set up frame base: B = SP
    TSX                     ; X = SP
    TXA                     ; A = SP
    STA R29                 ; Temp storage in DP
    SB  R29                 ; B = SP (frame base)
    
    ; Save callee-saved registers used in this function
    LDA R16
    PHA
    LDA R17
    PHA
    ; ... etc for each used callee-saved register
```

### 5.3 Function Epilogue

```asm
    ; Restore callee-saved registers (reverse order)
    PLA
    STA R17
    PLA
    STA R16
    ; ... etc
    
    ; Deallocate locals (if allocated)
    TSX                     ; X = SP
    TXA                     ; A = SP
    CLC
    ADC #locals_size        ; A = SP + locals_size
    TAX
    TXS                     ; SP restored
    
    ; Restore B register (frame pointer)
    PLB
    RTS                     ; Return
```

### 5.4 Leaf Function Optimization

Leaf functions (functions that don't call other functions) may:
- Skip saving/restoring the return address
- Use caller-saved registers freely
- Avoid frame pointer setup

---

## 6. Stack Frame Layout

### 6.1 Stack Growth

The stack grows **downward** (toward lower addresses).

### 6.2 Stack Alignment

- Minimum stack alignment: 4 bytes
- Function call stack alignment: 4 bytes

### 6.3 Frame Layout

```
High addresses
┌─────────────────────────┐
│   Caller's frame        │
├─────────────────────────┤
│   Stack arguments       │  ← Arguments beyond R7 (if any)
│   (arg8, arg9, ...)     │
├─────────────────────────┤ ◀── Caller's SP before call
│   Return address        │  ← Pushed by JSR (32-bit)
├─────────────────────────┤
│   Saved B register      │  ← Old B (caller's frame pointer)
├─────────────────────────┤
│   Local variables       │  ← Function's stack frame
├─────────────────────────┤ ◀── Frame Pointer (B) points here
│   Callee-saved regs     │  ← R16-R23, R48-R55, F12-F15 if used
├─────────────────────────┤
│   Spill slots           │  ← Register spills
├─────────────────────────┤
│   Outgoing arguments    │  ← For calls made by this function
│   (beyond R7)           │
├─────────────────────────┤ ◀── Stack Pointer (SP)
Low addresses
```

### 6.4 Accessing Stack Variables

| Location | Access Method |
|----------|---------------|
| Local variables | `B+$offset` (positive offset from frame base) |
| Incoming stack args | Above return address (accessed via SP before prologue) |
| Outgoing stack args | `SP + offset` (before call) |

**Note:** The B register is set to SP after stack allocation, making local variable access straightforward via `B+$offset` addressing. This is more efficient than traditional FP-relative addressing.

---

## 7. Return Values

### 7.1 Scalar Return Values

| Type | Size | Return Location |
|------|------|-----------------|
| `_Bool`, `char`, `short` | ≤4 bytes | R0 (zero/sign extended to 32-bit) |
| `int`, `long`, pointer | 4 bytes | R0 |
| `long long` | 8 bytes | R0 (low), R1 (high) |

### 7.2 Floating-Point Return Values (with FPU)

| Type | Return Location |
|------|-----------------|
| `float` | F0 (single-precision, low 32 bits) |
| `double` | F0 (double-precision, full 64 bits) |
| `long double` | F0 (same as double) |
| `_Complex float` | F0 (real), F1 (imaginary) |
| `_Complex double` | F0 (real), F1 (imaginary) |

### 7.3 Floating-Point Return Values (soft-float, no FPU)

When compiled without FPU (`-mcpu=m65832`), floating-point values are returned in GPRs:

| Type | Return Location |
|------|-----------------|
| `float` | R0 (bit-cast) |
| `double` | R0 (low), R1 (high) |

### 7.4 Aggregate Return Values

| Size | Return Method |
|------|---------------|
| ≤ 4 bytes | R0 |
| ≤ 8 bytes | R0:R1 |
| > 8 bytes | Caller provides pointer in hidden first argument |

For large structs, the caller allocates space and passes a pointer as an implicit first argument. The callee copies the return value to this location and returns the pointer in R0.

---

## 8. Parameter Passing

### 8.1 Register Arguments

The first 8 scalar arguments are passed in R0-R7:

```c
int func(int a, int b, int c, int d, int e, int f, int g, int h);
//       R0     R1     R2     R3     R4     R5     R6     R7
```

### 8.2 Stack Arguments

Arguments beyond the first 8 are passed on the stack, pushed right-to-left:

```c
int func(int a, int b, int c, int d, int e, int f, int g, int h, int i, int j);
//       R0    R1     R2     R3     R4     R5     R6     R7    [SP+4] [SP+0]
```

### 8.3 Argument Promotion

Small integer types are promoted before passing:
- `_Bool`, `char`, `short` → sign/zero extended to `int` (32-bit)

### 8.4 64-bit Arguments

64-bit arguments (`long long`, `double`) use register pairs:

```c
long long func(long long x, int y);
//             R0:R1       R2
```

Register pairs are even-aligned: (R0:R1), (R2:R3), (R4:R5), (R6:R7).

If an odd register would be used, it is skipped:
```c
int func(int a, long long b);
//       R0     R2:R3  (R1 skipped)
```

---

## 9. Variadic Functions

### 9.1 Variadic Argument Passing

For variadic functions (`printf`, etc.):

1. Named arguments follow standard rules (R0-R7, then stack)
2. Variadic arguments are passed on the stack
3. The last named argument may also be placed on stack to establish the va_list base

### 9.2 va_list Implementation

```c
typedef struct {
    char *stack_ptr;    // Pointer to next variadic argument on stack
} va_list[1];
```

### 9.3 va_start / va_arg / va_end

```c
void va_start(va_list ap, last_named);  // Initialize ap
type va_arg(va_list ap, type);          // Get next argument
void va_end(va_list ap);                // Clean up (no-op)
```

---

## 10. Struct and Union Passing

### 10.1 Small Structs (≤ 8 bytes)

Structs that fit in 1-2 registers are passed in registers:

| Size | Registers |
|------|-----------|
| 1-4 bytes | 1 register (R0-R7) |
| 5-8 bytes | 2 registers (e.g., R0:R1) |

### 10.2 Large Structs (> 8 bytes)

Structs larger than 8 bytes are passed by reference:
1. Caller copies struct to stack (or uses existing location)
2. Pointer to struct passed in register

### 10.3 Struct Return

| Size | Method |
|------|--------|
| ≤ 8 bytes | Returned in R0 (or R0:R1) |
| > 8 bytes | Caller provides destination pointer |

---

## 11. Thread Local Storage

### 11.1 TLS Model

The M65832 supports the following TLS models:

| Model | Use Case |
|-------|----------|
| Local Exec | Main executable, known at link time |
| Initial Exec | Shared libraries, loaded at startup |
| General Dynamic | Shared libraries, dlopen() |

### 11.2 TLS Access

TLS variables are accessed via a thread pointer register (implementation-defined, typically a reserved register or system call).

---

## 12. Exception Handling

### 12.1 Current Status

Exception handling (C++ exceptions, `setjmp`/`longjmp`) is not yet implemented.

### 12.2 Planned Support

- DWARF-based unwinding for C++ exceptions
- `setjmp`/`longjmp` support in libc

---

## 13. LLVM Implementation Details

### 13.1 Calling Convention Definition

The calling convention is defined in `M65832CallingConv.td`:

```tablegen
// Return values (hard-float)
def RetCC_M65832 : CallingConv<[
  CCIfType<[i1, i8, i16], CCPromoteToType<i32>>,
  CCIfType<[i32], CCAssignToReg<[R0]>>,
  CCIfType<[i64], CCAssignToRegWithShadow<[R0], [R1]>>,
  CCIfType<[f32], CCAssignToReg<[F0]>>,
  CCIfType<[f64], CCAssignToReg<[F0]>>
]>;

// Arguments (hard-float)
def CC_M65832 : CallingConv<[
  CCIfType<[i1, i8, i16], CCPromoteToType<i32>>,
  CCIfType<[i32], CCAssignToReg<[R0, R1, R2, R3, R4, R5, R6, R7]>>,
  CCIfType<[i64], CCAssignToRegWithShadow<[R0, R2, R4, R6], [R1, R3, R5, R7]>>,
  CCIfType<[f32], CCAssignToReg<[F0, F1, F2, F3, F4, F5, F6, F7]>>,
  CCIfType<[f64], CCAssignToReg<[F0, F1, F2, F3, F4, F5, F6, F7]>>,
  CCIfByVal<CCPassByVal<4, 4>>,
  CCIfType<[i32], CCAssignToStack<4, 4>>,
  CCIfType<[i64], CCAssignToStack<8, 4>>,
  CCIfType<[f32, f64], CCAssignToStack<8, 8>>
]>;

// Callee-saved registers
// Note: B register (frame pointer) is saved via PHB/PLB in prologue/epilogue
def CSR_M65832 : CalleeSavedRegs<(add
  R16, R17, R18, R19, R20, R21, R22, R23,   // GPR callee-saved
  R48, R49, R50, R51, R52, R53, R54, R55,   // Extended GPR callee-saved
  F12, F13, F14, F15                         // FPR callee-saved
)>;
```

### 13.2 Register Window Mapping

Direct Page addresses map to hardware registers when R=1:

| DP Address | Register | DP Address | Register |
|------------|----------|------------|----------|
| $00 | R0 | $80 | R32 |
| $04 | R1 | $84 | R33 |
| $08 | R2 | $88 | R34 |
| ... | ... | ... | ... |
| $7C | R31 | $FC | R63 |

Formula: `Register = DP_Address / 4`

### 13.3 Instruction Selection Notes

The LLVM backend generates:
- `LD Rn, #imm` for loading constants
- `ADD Rn, Rm` for register-to-register operations
- `SHL Rn, Rm, #count` for shifts
- Stack operations via SP-relative addressing

### 13.4 Compiler Flags

| Flag | Description |
|------|-------------|
| `-march=m65832` | Target M65832 architecture |
| `-mcpu=m65832` | Standard CPU (with HWMul, Atomics) |
| `-mcpu=m65832-fpu` | CPU with FPU support |

---

## Appendix A: Quick Reference

### Register Summary

```
GPR Caller-saved: R0-R15, R30, R32-R47, A, X, Y
GPR Callee-saved: R16-R23, R48-R55
GPR Reserved:     R24-R29, R31, R56-R63 (kernel use)
GPR Arguments:    R0-R7
GPR Return:       R0 (32-bit), R0:R1 (64-bit)
Frame ptr:        B (saved via PHB/PLB)
Stack ptr:        SP

FPR Caller-saved: F0-F11
FPR Callee-saved: F12-F15
FPR Arguments:    F0-F7
FPR Return:       F0 (float/double)
```

### Function Call Sequence

```asm
; Caller:
    LD   R0, arg0           ; First argument
    LD   R1, arg1           ; Second argument
    JSR  function           ; Call
    ; Return value in R0

; Callee:
function:
    ; Save callee-saved regs if used
    ; ... function body ...
    LD   R0, result         ; Return value
    RTS
```

---

## See Also

- [M65832 Architecture Reference](M65832_Architecture_Reference.md)
- [M65832 Instruction Set](M65832_Instruction_Set.md)
- [M65832 Assembler Reference](M65832_Assembler_Reference.md)

---

*Document Version: 1.0*  
*Last Updated: January 2026*
