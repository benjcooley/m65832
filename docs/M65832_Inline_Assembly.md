# M65832 Inline Assembly Reference

This document describes the inline assembly support for the M65832 architecture in Clang/LLVM.

## Overview

The M65832 backend supports GCC-style inline assembly with the following features:
- Register constraints for GPRs (R0-R63), Accumulator, X/Y index registers, and FPU registers
- Memory and immediate operands
- Clobber lists for registers and memory
- Named register variables
- Local labels for control flow

## For 6502/65816 Programmers

If you're familiar with classic 6502 or 65816 assembly, here are the key differences in M65832 32-bit mode:

### Register Sizes

| Register | 6502 | 65816 | M65832 (32-bit) |
|----------|------|-------|-----------------|
| A (Accumulator) | 8-bit | 8/16-bit | 32-bit |
| X (Index) | 8-bit | 8/16-bit | 32-bit |
| Y (Index) | 8-bit | 8/16-bit | 32-bit |
| SP (Stack Pointer) | 8-bit | 16-bit | 32-bit |
| PC (Program Counter) | 16-bit | 16-bit (+PBR) | 32-bit |

### General Purpose Registers (R0-R63) — Use Register Names

The M65832 introduces 64 general-purpose 32-bit registers (R0-R63). These replace the Direct Page (Zero Page) concept from the 6502:

| 6502/65816 (old) | M65832 (correct) | Notes |
|------------------|------------------|-------|
| `LDA $00` | `LDA R0` | Use R0, not $00 |
| `LDA $04` | `LDA R1` | Use R1, not $04 |
| `LDA $FC` | `LDA R63` | Use R63, not $FC |
| `STA dp` | `STA Rn` | Always use Rn syntax |

The legacy mapping is: **Rn = Direct Page address (n × 4)**

> **Important:** Do not use Zero Page / Direct Page syntax (`$00`, `$04`, etc.) to access R registers in new M65832 code. While the assembler accepts it for backwards compatibility, this creates confusion:
> - R0-R63 are **true CPU registers**, not memory locations
> - Using `$00` makes it look like a memory access when it's actually a register
> - The compiler always generates register names (R0, R1, etc.)
> 
> **Correct:**
> ```asm
> LDA R0          ; Load from register R0
> STA R5          ; Store to register R5
> ADC R10         ; Add register R10
> ```
> 
> **Avoid:**
> ```asm
> LDA $00         ; Confusing - looks like memory, but it's R0
> STA $14         ; Confusing - this is actually R5
> ADC $28         ; Confusing - this is actually R10
> ```

### No Size Flags (M/X Bits Ignored)

The 65816 uses the M and X status flags to switch between 8-bit and 16-bit register sizes. In M65832 32-bit mode, **these flags are ignored**—all registers are always 32-bit:

| 65816 | M65832 | Notes |
|-------|--------|-------|
| `REP #$30` | Not needed | No 8/16-bit modes |
| `SEP #$30` | Not needed | Always 32-bit |
| `.a16` / `.i16` | Not needed | Assembler directives ignored |

Any code that relies on switching register sizes will not work as expected. M65832 is a clean 32-bit architecture.

### No RTL/JSL — Use JSR/RTS

The 65816 long subroutine instructions (`JSL`, `RTL`) are **illegal** in M65832. Since all addresses are 32-bit, the standard instructions handle full addressing:

| 65816 | M65832 | Notes |
|-------|--------|-------|
| `JSL $123456` | `JSR $123456` | JSR uses 32-bit absolute address |
| `RTL` | `RTS` | RTS returns to 32-bit address |
| `JSR $1234` | `JSR $00001234` | All JSR is 32-bit (no "short" form) |

> **Important:** `JSL` and `RTL` will cause an illegal instruction exception. Always use `JSR` and `RTS`.

### No `.L` Suffix — Don't Use It

In 65816, you needed `.L` (long) suffixes to specify 32-bit operations. In M65832 32-bit mode, **all operations are 32-bit by default**, so the `.L` suffix is unnecessary and should not be used:

| 65816 (old) | M65832 (correct) | Notes |
|-------------|------------------|-------|
| `LDA.L $123456` | `LDA $123456` | Long addressing is default |
| `ADC.L #$12345678` | `ADC #$12345678` | 32-bit immediate is default |
| `LD.L R0, R1` | `LD R0, R1` | Extended ALU uses 32-bit |

> **Important:** Do not use the `.L` suffix in new M65832 code. While the assembler accepts it for backwards compatibility, it is redundant and will not be generated by the compiler. Using it creates confusion about whether you're writing 65816 or M65832 code.

### Immediate Values

All immediate values are 32-bit:

```asm
LDA #$12345678    ; Load 32-bit immediate (not #$12 like 6502)
LDX #1000         ; Decimal immediates work too
ADC #$FF          ; Still works, zero-extended to 32 bits
```

### Branch Offsets

Branch instructions use 16-bit signed offsets (±32KB range), not 8-bit:

```asm
BEQ label         ; Can branch ±32KB, not just ±127 bytes
BNE far_away      ; No need for BNE *+5 / JMP far_away tricks
```

### New Extended ALU Instructions

M65832 adds register-to-register ALU operations that don't require the accumulator:

| Instruction | Description | 6502 Equivalent |
|-------------|-------------|-----------------|
| `LD Rd, Rs` | Rd = Rs | LDA dp / STA dp |
| `LD Rd, #imm` | Rd = immediate | LDA #imm / STA dp |
| `CMP Ra, Rb` | Compare registers | LDA Ra / CMP Rb |
| `CMP Ra, #imm` | Compare with immediate | LDA Ra / CMP #imm |
| `INC Rd` | Rd = Rd + 1 | INC dp |
| `DEC Rd` | Rd = Rd - 1 | DEC dp |

### Stack Operations

The stack pointer is 32-bit and grows downward (same direction as 6502):

```asm
PHA               ; Push 32-bit A (4 bytes)
PHX               ; Push 32-bit X (4 bytes)
PHY               ; Push 32-bit Y (4 bytes)
PLA               ; Pull 32-bit A
PLX               ; Pull 32-bit X
PLY               ; Pull 32-bit Y
```

### Addressing Modes Summary

| Mode | 6502 Syntax | M65832 Syntax | Notes |
|------|-------------|---------------|-------|
| Immediate | `#$12` | `#$12345678` | 32-bit values |
| Register (DP) | `$00` | `R0` | R0-R63 = DP $00-$FC |
| Absolute | `$1234` | `$12345678` | 32-bit addresses |
| Indirect | `($00)` | `(R0)` | Through register |
| Indexed Indirect | `($00,X)` | `(R0,X)` | Pre-indexed |
| Indirect Indexed | `($00),Y` | `(R0),Y` | Post-indexed |
| Bank-relative | N/A | `B+symbol` | Relative to B register |

### New Instructions Not in 6502

| Instruction | Description |
|-------------|-------------|
| `LD Rd, src` | Load register directly |
| `fence` | Memory barrier (full) |
| `fencer` | Memory barrier (read) |
| `fencew` | Memory barrier (write) |
| `trap #n` | System call |
| `lli Rd, (Rs)` | Load-linked (atomic) |
| `sci Rd, (Rs)` | Store-conditional (atomic) |
| `cas` | Compare-and-swap (atomic) |

### FPU Registers

M65832 adds 16 floating-point registers (F0-F15) for hardware floating-point:

```asm
FADD F0, F1       ; F0 = F0 + F1
FMUL F2, F3       ; F2 = F2 * F3
FCVT.SD F0, F1    ; Convert F1 (single) to F0 (double)
```

### Quick Migration Examples

**6502 loop:**
```asm
        LDX #$00
loop:   LDA table,X
        STA result,X
        INX
        CPX #$10
        BNE loop
```

**M65832 equivalent:**
```asm
        LDX #0
.LLOOP: LDA B+table,X
        STA B+result,X
        INX
        CPX #16
        BNE .LLOOP
```

**6502 16-bit add (two bytes):**
```asm
        CLC
        LDA num1
        ADC num2
        STA result
        LDA num1+1
        ADC num2+1
        STA result+1
```

**M65832 32-bit add (single instruction):**
```asm
        CLC
        LDA R0          ; num1 already in R0
        ADC R1          ; num2 in R1
        STA R2          ; result in R2
```

Or using extended ALU:
```asm
        LD R2, R0       ; R2 = R0
        ; (use ADD when available, or ADC through A)
```

## Basic Syntax

```c
asm volatile(
    "assembly template"
    : output operands
    : input operands
    : clobbers
);
```

### Example

```c
int add_five(int x) {
    int result;
    asm volatile(
        "LDA %1\n"
        "CLC\n"
        "ADC #5\n"
        "STA %0"
        : "=r"(result)    // Output: result in any GPR
        : "r"(x)          // Input: x in any GPR
        : "a"             // Clobbers: accumulator
    );
    return result;
}
```

## Register Constraints

### General Purpose Registers

| Constraint | Description | Registers |
|------------|-------------|-----------|
| `r` | Any general-purpose register | R0-R63 |
| `a` | Accumulator | A |
| `x` | X index register | X |
| `y` | Y index register | Y |
| `f` | FPU register | F0-F15 |

### Constraint Modifiers

| Modifier | Description | Example |
|----------|-------------|---------|
| `=` | Write-only output | `"=r"(result)` |
| `+` | Read-write (input and output) | `"+r"(value)` |
| `&` | Early clobber (output written before inputs consumed) | `"=&r"(temp)` |

### Tied Operands

Use numeric constraints to tie an output to an input:

```c
int increment(int x) {
    asm volatile(
        "LDA %0\n"
        "CLC\n"
        "ADC #1\n"
        "STA %0"
        : "=r"(x)
        : "0"(x)      // Input tied to output %0
        : "a"
    );
    return x;
}
```

## Named Register Variables

For explicit register placement (useful for syscalls):

```c
void syscall_exit(int code) {
    register int r0 __asm__("r0") = 1;     // Syscall number
    register int r1 __asm__("r1") = code;  // Exit code
    
    asm volatile(
        "trap #0"
        :
        : "r"(r0), "r"(r1)
        : "memory"
    );
}
```

## Clobber List

### Register Clobbers

Declare registers modified by the assembly:

```c
asm volatile(
    "LDA %1\n"
    "STA %0"
    : "=r"(dst)
    : "r"(src)
    : "a"           // A is clobbered
);
```

Common register clobbers:
- `"a"` - Accumulator
- `"x"` - X index register
- `"y"` - Y index register
- `"r0"` through `"r63"` - Specific GPR

### Special Clobbers

| Clobber | Description |
|---------|-------------|
| `"memory"` | Assembly reads/writes memory not in operand list |
| `"cc"` | Assembly modifies condition codes (status register) |

## Memory Operations

### Indirect Addressing

Load/store through a pointer:

```c
int load_indirect(int *ptr) {
    int val;
    asm volatile(
        "LDA (%1)\n"
        "STA %0"
        : "=r"(val)
        : "r"(ptr)
        : "a"
    );
    return val;
}
```

### Y-Indexed Indirect

Access array elements:

```c
int load_indexed(int *base, int offset) {
    int val;
    asm volatile(
        "LDY %2\n"
        "LDA (%1),Y\n"
        "STA %0"
        : "=r"(val)
        : "r"(base), "r"(offset)
        : "a", "y"
    );
    return val;
}
```

## Local Labels

Use uppercase `.L` prefix labels for control flow:

```c
int max(int a, int b) {
    int result;
    asm volatile(
        "LDA %1\n"
        "CMP %2\n"
        "BCS .LGEQ\n"      // Branch if a >= b
        "LDA %2\n"         // a < b, load b
        "BRA .LEND\n"
        ".LGEQ:\n"         // a >= b, keep a
        ".LEND:\n"
        "STA %0"
        : "=r"(result)
        : "r"(a), "r"(b)
        : "a"
    );
    return result;
}
```

**Note:** Labels must be uppercase (e.g., `.LSKIP`, `.LLOOP`) for compatibility with the m65832as assembler.

## Memory Barriers

### Full Fence

```c
asm volatile("fence" : : : "memory");
```

### Read/Write Fences

```c
asm volatile("fencer" : : : "memory");  // Read fence
asm volatile("fencew" : : : "memory");  // Write fence
```

### Compiler Barrier

Prevent compiler reordering without hardware fence:

```c
asm volatile("" : : : "memory");
```

## Atomic Operations

The M65832 provides load-linked/store-conditional instructions for lock-free atomics:

### Load-Linked (LLI)

```c
int atomic_load(volatile int *ptr) {
    int val;
    asm volatile(
        "lli %0, (%1)"
        : "=r"(val)
        : "r"(ptr)
        : "memory"
    );
    return val;
}
```

### Store-Conditional (SCI)

```c
int atomic_store_conditional(volatile int *ptr, int val) {
    int success;
    asm volatile(
        "sci %1, (%2)\n"
        "LDA #1\n"
        "BCS .LSUCCESS\n"
        "LDA #0\n"
        ".LSUCCESS:\n"
        "STA %0"
        : "=r"(success)
        : "r"(val), "r"(ptr)
        : "a", "memory", "cc"
    );
    return success;
}
```

### Compare-And-Swap (CAS)

```c
int compare_and_swap(volatile int *ptr, int expected, int desired) {
    int old;
    asm volatile(
        "cas %0, (%1), %2, %3"
        : "=r"(old)
        : "r"(ptr), "r"(expected), "r"(desired)
        : "memory", "cc"
    );
    return old;
}
```

## Syscall Pattern

Standard syscall interface using trap instruction:

```c
static inline long __syscall3(long n, long a, long b, long c) {
    register long r0 __asm__("r0") = n;
    register long r1 __asm__("r1") = a;
    register long r2 __asm__("r2") = b;
    register long r3 __asm__("r3") = c;
    
    asm volatile(
        "trap #0"
        : "=r"(r0)
        : "0"(r0), "r"(r1), "r"(r2), "r"(r3)
        : "memory"
    );
    return r0;
}
```

## Shift and Logic Operations

### Shift Left (Multiply by 2^n)

```c
int shift_left(int x, int n) {
    asm volatile(
        "LDA %0\n"
        "ASL A\n"       // Shift left 1
        "STA %0"
        : "+r"(x)
        :
        : "a"
    );
    return x;
}
```

### Logical Operations

```c
int bitwise_and(int a, int b) {
    int result;
    asm volatile(
        "LDA %1\n"
        "AND %2\n"
        "STA %0"
        : "=r"(result)
        : "r"(a), "r"(b)
        : "a"
    );
    return result;
}
```

## Extended ALU Instructions

### Register-to-Register Load

```c
int copy_reg(int src) {
    int dst;
    asm volatile(
        "LD %0, %1"
        : "=r"(dst)
        : "r"(src)
    );
    return dst;
}
```

### Register Compare

```c
int compare(int a, int b) {
    int result = 0;
    asm volatile(
        "CMP %1, %2\n"
        "BNE .LNEQ\n"
        "LD %0, #1\n"
        ".LNEQ:\n"
        : "=r"(result)
        : "r"(a), "r"(b)
    );
    return result;
}
```

## Index Register Operations

```c
void index_example(void) {
    int val;
    
    // Load X, increment, transfer to A
    asm volatile(
        "LDX #10\n"
        "INX\n"
        "TXA\n"
        "STA %0"
        : "=r"(val)
        :
        : "a", "x"
    );
    // val == 11
    
    // Load Y, decrement, transfer to A
    asm volatile(
        "LDY #20\n"
        "DEY\n"
        "TYA\n"
        "STA %0"
        : "=r"(val)
        :
        : "a", "y"
    );
    // val == 19
}
```

## Instruction Reference

### ALU Instructions

| Instruction | Description |
|-------------|-------------|
| `LDA src` | Load accumulator from source |
| `STA dst` | Store accumulator to destination |
| `ADC src` | Add with carry: A = A + src + C |
| `SBC src` | Subtract with borrow: A = A - src - !C |
| `AND src` | Bitwise AND: A = A & src |
| `ORA src` | Bitwise OR: A = A \| src |
| `EOR src` | Bitwise XOR: A = A ^ src |
| `CMP src` | Compare A with source (sets flags) |
| `ASL A` | Arithmetic shift left accumulator |
| `LSR A` | Logical shift right accumulator |
| `ROL A` | Rotate left through carry |
| `ROR A` | Rotate right through carry |

### Index Register Instructions

| Instruction | Description |
|-------------|-------------|
| `LDX src` | Load X register |
| `LDY src` | Load Y register |
| `STX dst` | Store X register |
| `STY dst` | Store Y register |
| `INX` | Increment X |
| `INY` | Increment Y |
| `DEX` | Decrement X |
| `DEY` | Decrement Y |
| `TAX` | Transfer A to X |
| `TXA` | Transfer X to A |
| `TAY` | Transfer A to Y |
| `TYA` | Transfer Y to A |

### Extended ALU Instructions

| Instruction | Description |
|-------------|-------------|
| `LD Rd, src` | Load register Rd from source |
| `CMP Ra, Rb` | Compare registers |
| `INC Rd` | Increment register |
| `DEC Rd` | Decrement register |
| `STZ dst` | Store zero |

### Control Flow

| Instruction | Description |
|-------------|-------------|
| `BEQ label` | Branch if equal (Z=1) |
| `BNE label` | Branch if not equal (Z=0) |
| `BCS label` | Branch if carry set (C=1) |
| `BCC label` | Branch if carry clear (C=0) |
| `BMI label` | Branch if minus (N=1) |
| `BPL label` | Branch if plus (N=0) |
| `BVS label` | Branch if overflow set (V=1) |
| `BVC label` | Branch if overflow clear (V=0) |
| `BRA label` | Branch always |

### System Instructions

| Instruction | Description |
|-------------|-------------|
| `trap #n` | System call with code n |
| `fence` | Full memory fence |
| `fencer` | Read memory fence |
| `fencew` | Write memory fence |
| `NOP` | No operation |
| `CLC` | Clear carry flag |
| `SEC` | Set carry flag |

### Atomic Instructions

| Instruction | Description |
|-------------|-------------|
| `lli Rd, (Rs)` | Load-linked: Rd = *Rs |
| `sci Rd, (Rs)` | Store-conditional: *Rs = Rd if not modified |
| `cas Rd, (Rs), Re, Rn` | Compare-and-swap |

## Known Limitations

### Memory Constraint ("m")

The `"m"` memory constraint is not fully supported. Use `"r"` constraint with explicit pointer dereferencing instead:

**Instead of:**
```c
// NOT SUPPORTED - may not work correctly
int src = 42;
int dst;
asm volatile("LDA %1\n STA %0" : "=m"(dst) : "m"(src) : "a");
```

**Use this workaround:**
```c
// SUPPORTED - use "r" with pointers and dereference in asm
int src = 42;
int dst;
int *src_ptr = &src;
int *dst_ptr = &dst;
asm volatile(
    "LDA (%1)\n"
    "STA (%0)"
    : 
    : "r"(dst_ptr), "r"(src_ptr)
    : "a", "memory"
);
```

### Numeric Labels

Numeric labels (`1:`, `1f`, `1b`) are converted to `.Ltmp` labels by the compiler. The external m65832as assembler uppercases all labels. Use uppercase `.L` prefix labels for best compatibility:

```c
// Use uppercase labels
asm volatile(
    "BNE .LSKIP\n"
    "LDA #99\n"
    ".LSKIP:\n"
    "STA %0"
    : "=r"(result) : : "a"
);
```

## Best Practices

### Inline Assembly Guidelines

1. **Always use `volatile`** for inline assembly with side effects
2. **Declare all clobbered registers** in the clobber list
3. **Use `"memory"` clobber** when accessing memory not in operands
4. **Use uppercase labels** (e.g., `.LLOOP`) for m65832as compatibility
5. **Prefer `"r"` constraint** over specific registers when possible
6. **Use named register variables** for ABI-specific register placement
7. **Add `"cc"` clobber** when modifying condition codes

### M65832 Assembly Style Guidelines

8. **Use register names (R0-R63)**, not Zero Page addresses ($00, $04, etc.)
   - R registers are true CPU registers, not memory locations
   - ZP syntax is only for backwards compatibility with legacy code
   
9. **Do not use the `.L` suffix** on instructions
   - All operations are 32-bit by default in M65832 mode
   - `.L` is redundant and creates confusion with 65816 code
   
10. **Use decimal for small immediates**, hex for bit patterns
    ```asm
    LDA #100          ; Decimal for counts/offsets
    AND #$FF00FF00    ; Hex for bit masks
    ```

## Test Suite

The inline assembly test suite is located at:
```
m65832/emu/c_tests/inline_asm/
```

Run all tests:
```bash
cd m65832/emu/c_tests
./test_inline_asm.sh
```

Tests cover:
- Basic GPR constraints (`r`, `+r`, `=&r`)
- Accumulator constraint (`a`)
- Index register constraints (`x`, `y`)
- Memory operations and barriers
- Local labels and control flow
- Syscall patterns
- Shift and logic operations
- Extended ALU instructions
